# Polymorph challenge

Task description:
```
You have many samples of malware, but it changes every time. 
Write a program that can discern between malicious and legitimate.

You can find the malware samples in the malware directory. 
The "malware" is not actually malicious and will not harm your computer. 
Instead, it will simply display the EICAR test file.
```
* Category: reversing
* Solved by: 33 teams
* Points: 246pt

The attachment aka the "public" part that the CTF participants got can be seen here: 
https://github.com/google/google-ctf/tree/master/2021/quals/rev-polymorph/attachments


## Introduction

The task is to write a program which acts as an antivirus/malware scanner. It must exit with error code `0` if the file is not malicious and `nonzero` if the file is considered malicious.
The attachment contained some samples to practice on, organized in two directories: 'malware' and 'safe' with 64 binaries each.
The program must have 100% accuracy on all those binaries.

The program can then be submitted to the Autograder which tests it on the server on a larger, secret set of binaries (100 each). If the program is considered accurate enough, the Autograder prints out the flag. Only a few mistakes are allowed, accuracy of the program must be close to 100%. The program must not take any longer than 4s per sample and it is executed in a sandbox so its capabilities are limited.

## Taking ideas from the AV industry

As this task was about reversing malware, our idea was to use YARA.

YARA is an open source malware scanning engine that has become a very commonly used tool in the AV and malware research industry. It looks for byte or string patterns which are defined in YARA rule definition files. Those files are created by malware researchers and many examples of rules can be found online.

Here is an example rule definition:
```
rule vendor
{
strings:
    $text_string1 = “Vendor name” wide
    $text_string2 = “Alias name” wide
condition:
    $text_string1 or $text_string2
}
```

Here is a tutorial on how to use YARA from the command-line:

https://yara.readthedocs.io/en/stable/commandline.html

Basic usage is:
```
yara [OPTIONS] RULES_FILE TARGET
```

We saw that YARA did not come with any rules on its own, so we began searching online. 
Most YARA rule files we could find were targeted at specific malware/ransomware samples found in the wild. Here is an example of a repository gathering such rules:
https://github.com/Yara-Rules/rules/tree/master/malware

The malware samples in the task were custom made so these rules were not much help. 
We could not find any generic Yara rules for Linux malware that would be extensive enough to cover the malware samples in the task.

Fortunately, we were able to find another very interesting tool.

## Getting help from some AI

We came across a [tool](https://github.com/sophos-ai/yaraml_rules) made by Sophos which automatically generates Yara rules using ML classifiers. The model must first be trained by passing two directories containing malware and benign files of any format. This sounded perfect, because we had exactly that! The model then generates a YARA rule file containing substring features with associated weights and a lot of sets of conditions which are used when rating a binary.

We got to work, writing a program which used `libyara` to read in the rule generated by the Sophos tool, compile the rule and then run the scan on a given binary.
Here is a snippet of the AV program:
```
YR_COMPILER* compiler;
YR_RULES* rules;
        
yr_initialize();
if (ERROR_SUCCESS != yr_compiler_create(&compiler))
        exit(-1);
if (yr_compiler_add_string(compiler, rule_string, NULL))
        exit(-2);
if (ERROR_SUCCESS != yr_compiler_get_rules(compiler, &rules))
        exit(-3);
yr_rules_scan_file(rules, argv[1] , 0, callback_function, NULL, 0);
```

So how did the rules generated by YaraML do?

In the first try, without tweaking any parameters, we got almost 100% accuracy on the public samples and around 70% accuracy on the secret set which was very promising. Still, it needed to do much better than that to satisfy the Autograder.

At first we were using the default LogisticRegression model and tweaked parameters such as l1 and the number of iterations. We tried different sets of parameters and was able to get over 80% accuracy with the resulting rule files.

Then we switched to the `randomforest` classifier which generated much more hefty rule files. After some tweaking we were able to reach nearly 100% accuracy on the secret set! The Autograder was pleased and kindly gave us the flag.

## Comparing with the official solution

The Google solution takes the approach of manually reading the binaries byte-by-byte forming n-grams of a certain size, hashing the n-grams and constructing a huge global list of n-gram hashes. Then the malware samples are cross-referenced to identify signature candidates, while removing the ngrams which were found multiple times in the benign samples. In essence it is a similar approach to ours - finding byte sequences which match on the most malicious binaries without hitting on benign binaries. The difference is that we did it in the ML-automated way.

Interestingly, we found [research](https://www.edwardraff.com/publications/what_can_ngrams_learn.pdf) which suggests that such brute-force approach of raw byte-scanning without trying to parse and identify binary metadata, take architecture or assembly mnemonics into account, might actually be more effective in identifying malware than more assembly-aware approaches.
